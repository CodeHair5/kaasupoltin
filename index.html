<!DOCTYPE html>
<html lang="fi">
<head>
    <title>Three.js Retkikeitin - Lopullinen versio</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #f0f0f0;
        }
        canvas { 
            display: block; 
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            color: #333;
            font-size: 16px;
        }
        #controls-container {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 10;
        }
        #buttons {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
        }
        button {
            padding: 12px 24px;
            font-size: 16px;
            cursor: pointer;
            background-color: #ffffff;
            border: 1px solid #cccccc;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            transition: background-color 0.2s, transform 0.1s;
        }
        button:hover {
            background-color: #e9e9e9;
        }
        button:active {
            transform: scale(0.98);
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        #flame-control-container {
            display: flex;
            align-items: center;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        #flame-control-container label {
            margin-right: 10px;
            font-weight: 500;
            color: #333;
        }
        #flame-slider {
            width: 200px;
        }
        #warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 100, 100, 0.9);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 15px rgba(0,0,0,0.3);
            font-size: 18px;
            text-align: center;
            z-index: 20;
            display: none; 
        }
    </style>
</head>
<body>

<div id="info">Pyöritä mallia hiirellä ja käytä painikkeita</div>
<div id="warning"></div>

<div id="controls-container">
    <div id="flame-control-container">
        <label for="flame-slider">Kaasun säätö:</label>
        <input type="range" id="flame-slider" min="0" max="180" value="0">
    </div>
    <div id="buttons">
        <button id="air-vent-btn">Avaa/Sulje ilma-aukko</button>
        <button id="light-match-btn">Sytytä tulitikku</button>
        <button id="move-match-btn">Vie tulitikku polttimeen</button>
    </div>
</div>

<script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
</script>

<script type="module">

    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    let scene, camera, renderer, controls;
    let leverGroup, ringAssembly, ringHole, matchstick, burnerParticles, matchParticles, smokeParticles;
    let flameSlider;
    let isGasValveOpen = false, isAirVentOpen = false, isStoveLit = false;
    let isMatchMoving = false, isMatchAtBurner = false;
    let targetLeverRotation = 0, targetRingRotation = 0;
    let flameIntensity = 0;
    let targetMatchPosition = new THREE.Vector3(4, 2, 0);
    let targetMatchQuaternion = new THREE.Quaternion();
    const clock = new THREE.Clock();

    function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(4, 5, 7);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
        directionalLight.position.set(5, 10, 7.5);
        scene.add(directionalLight);
        createCampingStove();
        createMatchstick();
        setupControls();
        animate();
    }

    function createCampingStove() {
        const stoveGroup = new THREE.Group();
        const brassMaterial = new THREE.MeshStandardMaterial({ color: 0xB5A642, metalness: 0.9, roughness: 0.3 });
        const valveYPos = 1.25 + 0.35;
        const pipeHeight = 1.5;
        const pipeYPos = valveYPos + 0.35 + (pipeHeight / 2);
        const burnerHeadYPos = pipeYPos + (pipeHeight / 2) - 0.05;

        stoveGroup.add(new THREE.Mesh(new THREE.CylinderGeometry(2, 2, 2.5, 32), new THREE.MeshStandardMaterial({ color: 0x00529B, metalness: 0.3, roughness: 0.6 })));
        const valve = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.7, 16), new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.4 }));
        valve.position.y = valveYPos;
        stoveGroup.add(valve);

        leverGroup = new THREE.Group();
        const leverArm = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.1, 0.2), new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.8 }));
        leverArm.position.x = 0.4;
        leverGroup.add(leverArm);

        const wheelGroup = new THREE.Group();
        const wheel = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.15, 16), leverArm.material);
        const lineMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
        const line1 = new THREE.Mesh(new THREE.PlaneGeometry(0.2, 0.03), lineMaterial);
        line1.position.y = 0.076; line1.rotation.x = -Math.PI / 2;
        const line2 = line1.clone();
        line2.position.y = -0.076; line2.rotation.x = Math.PI / 2;
        wheel.add(line1, line2);
        wheel.rotation.z = Math.PI / 2;
        wheelGroup.add(wheel);
        wheelGroup.position.x = 0.8;
        leverGroup.add(wheelGroup);
        
        leverGroup.position.set(0.5, valveYPos, 0);
        stoveGroup.add(leverGroup);

        const pipe = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, pipeHeight, 16), brassMaterial);
        pipe.position.y = pipeYPos;
        stoveGroup.add(pipe);
        const burnerHead = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.1, 16), brassMaterial);
        burnerHead.position.y = burnerHeadYPos;
        stoveGroup.add(burnerHead);

        ringAssembly = new THREE.Group();
        ringAssembly.position.y = valveYPos + 0.35 + 0.15;
        const ringTubeRadius = 0.1;
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.22, ringTubeRadius, 8, 32), brassMaterial);
        ring.rotation.x = Math.PI / 2;
        ringAssembly.add(ring);
        ringHole = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, ringTubeRadius * 2.1, 12), new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.2 }));
        ringHole.position.z = 0.22; ringHole.rotation.x = Math.PI / 2; ringHole.visible = false;
        ringAssembly.add(ringHole);
        const handle = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.4), brassMaterial);
        handle.position.z = -0.22;
        ringAssembly.add(handle);
        stoveGroup.add(ringAssembly);
        scene.add(stoveGroup);

        burnerParticles = createParticleSystem(300, 0.25);
        burnerParticles.position.y = burnerHeadYPos + 0.05;
        burnerParticles.visible = false;
        scene.add(burnerParticles);
        
        smokeParticles = createSmokeSystem(50, 0.25);
        smokeParticles.position.y = burnerHeadYPos + 0.05;
        smokeParticles.visible = false;
        scene.add(smokeParticles);
    }

    function createMatchstick() {
        matchstick = new THREE.Group();
        matchstick.add(new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 2, 8), new THREE.MeshStandardMaterial({ color: 0xdeb887 })));
        matchstick.add(new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), new THREE.MeshStandardMaterial({ color: 0x8b0000 })).translateY(1));
        
        matchParticles = createParticleSystem(50, 0.1);
        scene.add(matchParticles); 
        matchParticles.visible = false;
        
        matchstick.position.copy(targetMatchPosition);
        matchstick.visible = false;
        scene.add(matchstick);
    }
    
    function createSmokeSystem(count, areaSize) {
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * areaSize;
            positions[i * 3 + 1] = Math.random() * 0.8;
            positions[i * 3 + 2] = (Math.random() - 0.5) * areaSize;
            velocities[i * 3] = (Math.random() - 0.5) * 0.15;
            velocities[i * 3 + 1] = Math.random() * 0.2 + 0.2;
            velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.15;
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.08,
            color: 0x222222,
            blending: THREE.NormalBlending,
            depthWrite: true,
            transparent: true,
            opacity: 0.5
        });

        return new THREE.Points(particles, particleMaterial);
    }

    function createParticleSystem(count, areaSize) {
        const particles = new THREE.BufferGeometry();
        const positions = new Float32Array(count * 3);
        const velocities = new Float32Array(count * 3);

        for (let i = 0; i < count; i++) {
            positions[i * 3] = (Math.random() - 0.5) * areaSize;
            positions[i * 3 + 1] = Math.random() * 0.5;
            positions[i * 3 + 2] = (Math.random() - 0.5) * areaSize;
            velocities[i * 3] = (Math.random() - 0.5) * 0.1;
            velocities[i * 3 + 1] = Math.random() * 0.5 + 0.5;
            velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.1;
        }

        particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
        particles.setAttribute('velocity', new THREE.BufferAttribute(velocities, 3));

        const particleMaterial = new THREE.PointsMaterial({
            size: 0.05,
            map: new THREE.CanvasTexture(generateSprite()),
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true
        });

        return new THREE.Points(particles, particleMaterial);
    }

    function generateSprite() {
        const canvas = document.createElement('canvas');
        canvas.width = 16; canvas.height = 16;
        const context = canvas.getContext('2d');
        const gradient = context.createRadialGradient(8, 8, 0, 8, 8, 8);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.4, 'rgba(200,200,200,1)');
        gradient.addColorStop(1, 'rgba(0,0,0,1)');
        context.fillStyle = gradient;
        context.fillRect(0, 0, 16, 16);
        return canvas;
    }

    function showWarning(message) {
        const warningDiv = document.getElementById('warning');
        warningDiv.textContent = message;
        warningDiv.style.display = 'block';
        setTimeout(() => { warningDiv.style.display = 'none'; }, 2500);
    }

    function setupControls() {
        flameSlider = document.getElementById('flame-slider');

        document.getElementById('air-vent-btn').addEventListener('click', () => {
            isAirVentOpen = !isAirVentOpen;
            targetRingRotation = isAirVentOpen ? Math.PI / 2 : 0;
            if (!isAirVentOpen) ringHole.visible = false;
        });

        document.getElementById('light-match-btn').addEventListener('click', () => {
            if (isStoveLit) {
                showWarning("Kaasupoltin on jo päällä!");
                return;
            }
            matchstick.visible = true;
            isMatchMoving = false;
            isMatchAtBurner = false;
            targetMatchPosition.set(4, 2, 0);
            targetMatchQuaternion.identity();
            matchstick.position.copy(targetMatchPosition);
            matchstick.quaternion.copy(targetMatchQuaternion);
        });

        document.getElementById('move-match-btn').addEventListener('click', () => {
            if (!matchstick.visible) return;
            if (isAirVentOpen) {
                showWarning("Ilma-aukon tulee olla sytytettäessä kiinni!");
                return;
            }
            
            targetMatchPosition.set(0, 3.2, 1.2);
            targetMatchQuaternion.setFromEuler(new THREE.Euler(-Math.PI / 2.5, 0, 0));
            isMatchMoving = true;
        });

        // --- MUOKATTU OSA: Kaasun säätimen logiikka ---
        flameSlider.addEventListener('input', (e) => {
            const sliderValue = parseInt(e.target.value);
            const wasGasValveOpen = isGasValveOpen; // Tallennetaan edellinen tila
            
            isGasValveOpen = sliderValue >= 10;
            flameIntensity = sliderValue / 180;
            
            targetLeverRotation = -sliderValue * (Math.PI / 180);

            // Varoitus, jos kaasu avataan ilman, että tulitikku on valmiina polttimella
            if (!wasGasValveOpen && isGasValveOpen && !isStoveLit && !isMatchAtBurner) {
                showWarning("Kaasuhanan saa avata vasta silloin kun tulitikku palaa polttimon yläpuolella!");
            }

            if (isGasValveOpen && isMatchAtBurner && !isStoveLit) {
                lightStove();
            } else if (!isGasValveOpen && isStoveLit) {
                extinguishStove();
            }
        });
        // --- MUOKKAUS PÄÄTTYY ---
    }

    function lightStove() {
        isStoveLit = true;
        matchstick.visible = false;
        isMatchAtBurner = false;
        burnerParticles.visible = true;
    }

    function extinguishStove() {
        isStoveLit = false;
        burnerParticles.visible = false;
    }

    // --- MUOKATTU OSA: Partikkelianimaatio ---
    function animateParticles(particleSystem, delta, color, intensity = 0.5) {
        const positions = particleSystem.geometry.attributes.position.array;
        const velocities = particleSystem.geometry.attributes.velocity.array;
        const isBurner = particleSystem === burnerParticles;
        const isSmoke = particleSystem === smokeParticles;

        // Muuttaa partikkelien kokoa reaaliaikaisesti tehonsäädön mukaan
        if (isBurner) {
            particleSystem.material.size = 0.03 + (intensity * 0.05); 
        }

        for (let i = 0; i < positions.length / 3; i++) {
            let speedMultiplier = 1.0;
            let heightLimit = 1.0;

            if (isBurner || isSmoke) {
                let currentIntensity = intensity;
                if(isBurner && isAirVentOpen) {
                   currentIntensity *= 0.5;
                }
                speedMultiplier = (0.5 + currentIntensity * 1.5);
                heightLimit = (0.5 + currentIntensity * 2.5);
            }
            
            positions[i * 3] += velocities[i * 3] * delta;
            positions[i * 3 + 1] += velocities[i * 3 + 1] * speedMultiplier * delta;
            positions[i * 3 + 2] += velocities[i * 3 + 2] * delta;

            if (positions[i * 3 + 1] > heightLimit) {
                positions[i * 3] = (Math.random() - 0.5) * 0.25;
                positions[i * 3 + 1] = 0;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 0.25;
            }
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
        if(color && particleSystem.material.color) {
            particleSystem.material.color.set(color);
        }
    }
    // --- MUOKKAUS PÄÄTTYY ---

    function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        leverGroup.rotation.x += (targetLeverRotation - leverGroup.rotation.x) * 0.1;
        ringAssembly.rotation.y += (targetRingRotation - ringAssembly.rotation.y) * 0.1;

        if (isAirVentOpen && Math.abs(ringAssembly.rotation.y - targetRingRotation) < 0.01) {
            ringHole.visible = true;
        }

        if (isMatchMoving) {
            matchstick.position.lerp(targetMatchPosition, 0.05);
            matchstick.quaternion.slerp(targetMatchQuaternion, 0.05);
            if (matchstick.position.distanceTo(targetMatchPosition) < 0.01) {
                isMatchMoving = false;
                isMatchAtBurner = true;
                if (isGasValveOpen && !isStoveLit) {
                    lightStove();
                }
            }
        }
        
        matchParticles.visible = matchstick.visible;
        if (matchstick.visible) {
            const tipPosition = new THREE.Vector3(0, 1.08, 0);
            matchstick.localToWorld(tipPosition);
            matchParticles.position.copy(tipPosition);
            animateParticles(matchParticles, delta, 0xffaa33);
        }
        
        if (isStoveLit) {
            const flameColor = isAirVentOpen ? 0x6699ff : 0xffcc33;
            animateParticles(burnerParticles, delta, flameColor, flameIntensity);
            
            if (!isAirVentOpen) {
                smokeParticles.visible = true;
                animateParticles(smokeParticles, delta, null, flameIntensity);
            } else {
                smokeParticles.visible = false;
            }
        } else {
             smokeParticles.visible = false;
        }

        controls.update();
        renderer.render(scene, camera);
    }
    
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }, false);

    init();

</script>
</body>
</html>